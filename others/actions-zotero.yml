type: ActionsTagsBackup
author: zwwen0711
platformVersion: 7.0.30
pluginVersion: 2.2.4
timestamp: '2025-12-28T17:22:32.173Z'
actions:
  1766933168242-lENQeb2s:
    event: 1
    operation: 4
    data: >-
      const MARKER_SUMMARY = "„Äêü§ñ AI Summary„Äë";
      const MARKER_CHAT = "„Äêüí¨ Chat History„Äë";
      const MARKER_ORIG = "„ÄêüìÑ Original Abstract„Äë";
      const MARKER_TLDR = "„Äêüìù TLDR„Äë";
      const MARKER_GLANCE = "„Äêüß≠ ÈÄüËßàÂå∫„Äë";
      const MARKER_DETAIL = "„Äêüß© ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªìÂå∫„Äë";
      const MARKER_GLANCE_LEGACY = "„Äêüß≠ Glance„Äë";
      const MARKER_DETAIL_LEGACY = "„Äêüß© ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªì„Äë";
      const BR_PLACEHOLDER = /__BR__/g;
      const AUTO_NOTE_TAG = "dpr-ai-summary-note";
      const RETRY_DELAYS = [300, 800, 1500];

      const targetItems = (typeof items !== "undefined" && items && items.length > 0)
        ? items
        : ((typeof item !== "undefined" && item) ? [item] : []);

      if (!targetItems || targetItems.length === 0) {
        return "‚ùå ÈîôËØØÔºöÊú™Êé•Êî∂Âà∞ÊúâÊïàÊù°ÁõÆÔºàËØ∑ÂÖàÂú®Êù°ÁõÆ‰∏äËß¶ÂèëËÑöÊú¨Ôºâ";
      }

      function normalizeText(v) {
        return (v || "").toString();
      }

      function normalizeSourceText(v) {
        const plain = normalizeText(v)
          .replace(/<br\s*\/?>/gi, "\n")
          .replace(/<\/p>/gi, "\n")
          .replace(/<p[^>]*>/gi, "")
          .replace(/<[^>]+>/g, "")
          .replace(BR_PLACEHOLDER, "\n")
          .replace(/\r/g, "\n");
        return plain
          .replace(/\n{3,}/g, "\n\n")
          .trim();
      }

      function hasAnyMarker(text) {
        return (
          text.includes(MARKER_SUMMARY) ||
          text.includes(MARKER_CHAT) ||
          text.includes(MARKER_ORIG) ||
          text.includes(MARKER_TLDR) ||
          text.includes(MARKER_GLANCE) ||
          text.includes(MARKER_GLANCE_LEGACY) ||
          text.includes(MARKER_DETAIL) ||
          text.includes(MARKER_DETAIL_LEGACY)
        );
      }

      function cleanForCompare(v) {
        return normalizeSourceText(v).replace(/\s+/g, "");
      }

      function normalizeSectionFingerprint(value) {
        return normalizeSourceText(value)
          .toLowerCase()
          .replace(/\s+/g, "")
          .replace(/\u200b/g, "");
      }

      function normalizeTitleKey(title) {
        return normalizeSourceText(title)
          .toLowerCase()
          .replace(/\s+/g, "")
          .replace(/[^\w\u4e00-\u9fa5]/g, "");
      }

      function escapeHtml(v) {
        return normalizeText(v)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function getFieldSafe(targetItem, fieldName) {
        try {
          return normalizeText(targetItem.getField(fieldName));
        } catch (err) {
          return "";
        }
      }

      function getSourceText(targetItem) {
        const candidateFields = [
          "citation_abstract",
          "abstractNote",
          "abstract",
          "description",
          "dc.description",
          "DC.description",
        ];
        let firstFieldFound = "";
        let firstText = "";
        for (const fieldName of candidateFields) {
          const rawValue = getFieldSafe(targetItem, fieldName);
          const raw = normalizeSourceText(rawValue);
          if (!raw) {
            continue;
          }
          if (!firstFieldFound) {
            firstFieldFound = fieldName;
            firstText = raw;
          }

          if (hasAnyMarker(raw)) {
            return {
              text: raw,
              field: fieldName,
            };
          }
        }

        return {
          text: firstText,
          field: firstFieldFound,
        };
      }

      function getMarkerTitle(lineText) {
        const text = normalizeText(lineText).trim();
        if (!text) return "";
        const markerText = [
          MARKER_SUMMARY,
          MARKER_CHAT,
          MARKER_ORIG,
          MARKER_TLDR,
          MARKER_GLANCE,
          MARKER_GLANCE_LEGACY,
          MARKER_DETAIL,
          MARKER_DETAIL_LEGACY,
        ].map((v) =>
          normalizeText(v).trim(),
        );
        const map = {
          [markerText[0]]: "ü§ñ AI Summary",
          [markerText[1]]: "üí¨ Chat History",
          [markerText[2]]: "üìÑ Original Abstract",
          [markerText[3]]: "üìù TLDR",
          [markerText[4]]: "üß≠ ÈÄüËßàÂå∫",
          [markerText[5]]: "üß≠ ÈÄüËßàÂå∫",
          [markerText[6]]: "üß© ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªìÂå∫",
          [markerText[7]]: "üß© ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªìÂå∫",
        };
        for (const marker of markerText) {
          if (text.startsWith(marker)) {
            return map[marker] || text;
          }
        }
        return "";
      }

      function trimLeadingMetadataLines(text) {
        const lines = normalizeSourceText(text).split("\n");
        const filtered = [];
        let started = false;
        for (const line of lines) {
          const t = line.trim();
          if (!t) {
            if (!started) {
              continue;
            }
          }
          if (!started && /^> Áî± daily-paper-reader Ëá™Âä®ÁîüÊàê/i.test(t)) {
            continue;
          }
          if (!started && t.includes("daily-paper-reader Ëá™Âä®ÁîüÊàê")) {
            continue;
          }
          started = true;
          filtered.push(t);
        }
        return filtered
          .join("\n")
          .replace(/\n{3,}/g, "\n\n")
          .trim();
      }

      function normalizeSectionTitle(line) {
        const text = normalizeText(line).trim();
        const markerTitle = getMarkerTitle(text);
        if (markerTitle) return markerTitle;
        return text
          .replace(/^#{1,6}\s*/, "")
          .replace(/^[ü§ñüí¨üìÑ]\s*/, "")
          .replace(/^\*\s*/, "")
          .trim();
      }

      function canonicalizeSectionTitle(line) {
        const raw = normalizeText(line || "").trim();
        const text = raw.toLowerCase();
        if (!text) {
          return "üìù ÊñáÁ´†ÂÜÖÂÆπ";
        }
        if (text.includes("ü§ñ") || text.includes("ai summary")) {
          return "ü§ñ AI Summary";
        }
        if (text.includes("üìù tldr") || text.includes("tldr")) {
          return "üìù TLDR";
        }
        if (text.includes("üí¨") || text.includes("chat history")) {
          return "üí¨ Chat History";
        }
        if (text.includes("üß≠ ÈÄüËßàÂå∫") || text.includes("ÈÄüËßàÂå∫")) {
          return "üß≠ ÈÄüËßàÂå∫";
        }
        if (
          text.includes("üß© ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªì") ||
          text.includes("ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªìÂå∫")
        ) {
          return "üß© ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªìÂå∫";
        }
        if (
          text.includes("üìÑ") ||
          text.includes("original abstract") ||
          text.includes("ÂéüÊñáÊëòË¶Å") ||
          text.includes("abstract") ||
          text === "ÊëòË¶Å"
        ) {
          return "üìÑ Original Abstract";
        }
        if (text.includes("paper-title-row") || text.includes("ÂèåËØ≠Ê†áÈ¢òÂå∫Âüü")) {
          return "paper-title-rowÔºàÂèåËØ≠Ê†áÈ¢òÂå∫ÂüüÔºâ";
        }
        if (text.includes("paper-meta-row") || text.includes("‰∏≠Èó¥‰ø°ÊÅØÂå∫")) {
          return "paper-meta-rowÔºà‰∏≠Èó¥‰ø°ÊÅØÂå∫Ôºâ";
        }
        if (text.includes("paper-glance-section") || text.includes("ÈÄüËßàÂç°")) {
          return "paper-glance-sectionÔºàÈÄüËßàÂç°Ôºâ";
        }
        if (
          text.includes("È°µÈù¢ÂØºËà™‰∏é‰∫§‰∫íÂ±Ç") ||
          text.includes("dpr-title-bar") ||
          text.includes("paper-chat-container") ||
          text.includes("chat-history")
        ) {
          return "È°µÈù¢ÂØºËà™‰∏é‰∫§‰∫íÂ±Ç";
        }
        if (text.includes("ËÆ∫ÊñáÊ≠£Êñá") || text.includes("paper-content")) {
          return "üìù ËÆ∫ÊñáÊ≠£Êñá";
        }
        if (text.includes("ÊñáÁ´†ÂÖÉ‰ø°ÊÅØ")) {
          return "üìã ÊñáÁ´†ÂÖÉ‰ø°ÊÅØ";
        }
        return normalizeSectionTitle(raw).trim();
      }

      function isSectionHeading(line) {
        const text = normalizeText(line).trim();
        if (!text) {
          return false;
        }
        if (getMarkerTitle(text)) {
          return true;
        }

        const fixedHeading = canonicalizeSectionTitle(text);
        const fixedHeadings = new Set([
          "ü§ñ AI Summary",
          "üí¨ Chat History",
          "üìÑ Original Abstract",
          "üìù TLDR",
          "üß≠ ÈÄüËßàÂå∫",
          "üß© ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªìÂå∫",
          "paper-title-rowÔºàÂèåËØ≠Ê†áÈ¢òÂå∫ÂüüÔºâ",
          "paper-meta-rowÔºà‰∏≠Èó¥‰ø°ÊÅØÂå∫Ôºâ",
          "paper-glance-sectionÔºàÈÄüËßàÂç°Ôºâ",
          "üìù ËÆ∫ÊñáÊ≠£Êñá",
          "üìã ÊñáÁ´†ÂÖÉ‰ø°ÊÅØ",
          "È°µÈù¢ÂØºËà™‰∏é‰∫§‰∫íÂ±Ç",
        ]);
        return fixedHeadings.has(fixedHeading);
      }

      function splitSectionsByHeadings(fullText) {
        const lines = normalizeSourceText(fullText).split("\n");
        const result = [];
        let currentTitle = "üìù ÊñáÁ´†ÂÜÖÂÆπ";
        let currentBuffer = [];

        const flush = () => {
          const content = trimLeadingMetadataLines(currentBuffer.join("\n"));
          if (content) {
            result.push({
              title: currentTitle,
              content,
            });
          }
          currentBuffer = [];
        };

        for (const rawLine of lines) {
          const headingTitle = normalizeSectionTitle(rawLine);
          if (isSectionHeading(rawLine)) {
            flush();
            currentTitle = headingTitle ? headingTitle : currentTitle;
            if (!currentTitle) {
              currentTitle = "üìù ÊñáÁ´†ÂÜÖÂÆπ";
            }
            continue;
          }
          currentBuffer.push(rawLine);
        }
        flush();

        return result;
      }

      function splitSectionsByKnownMarkdownHeadings(fullText) {
        const text = normalizeSourceText(fullText);
        const headingSpecs = [
          {
            title: "ü§ñ AI Summary",
            regex: /#{1,6}\s*ü§ñ\s*AI\s*Summary/i,
          },
          {
            title: "ü§ñ AI Summary",
            regex: /#{1,6}\s*AI\s*Summary/i,
          },
          {
            title: "üí¨ Chat History",
            regex: /#{1,6}\s*üí¨\s*Chat\s*History/i,
          },
          {
            title: "üí¨ Chat History",
            regex: /#{1,6}\s*Chat\s*History/i,
          },
          {
            title: "üìÑ Original Abstract",
            regex: /#{1,6}\s*üìÑ\s*(?:Original\s*Abstract|ÂéüÊñáÊëòË¶Å|Abstract|ÊëòË¶Å)/i,
          },
          {
            title: "üìÑ Original Abstract",
            regex: /#{1,6}\s*(?:Original\s*Abstract|ÂéüÊñáÊëòË¶Å|Abstract|ÊëòË¶Å)/i,
          },
          {
            title: "üìù TLDR",
            regex: /#{1,6}\s*üìù\s*TLDR/i,
          },
          {
            title: "üìù TLDR",
            regex: /#{1,6}\s*TLDR/i,
          },
          {
            title: "üß≠ ÈÄüËßàÂå∫",
            regex: /#{1,6}\s*üß≠\s*ÈÄüËßàÂå∫/i,
          },
          {
            title: "üß≠ ÈÄüËßàÂå∫",
            regex: /#{1,6}\s*ÈÄüËßàÂå∫/i,
          },
          {
            title: "üß© ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªìÂå∫",
            regex: /#{1,6}\s*üß©\s*ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªì(?:Âå∫|ÔºàËá™Âä®ÁîüÊàêÔºâ)?/i,
          },
          {
            title: "üß© ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªìÂå∫",
            regex: /#{1,6}\s*ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªì(?:Âå∫|ÔºàËá™Âä®ÁîüÊàêÔºâ)?/i,
          },
        ];

        const matches = [];
        headingSpecs.forEach((spec) => {
          const pattern = new RegExp(spec.regex.source, 'gi');
          let m;
          while ((m = pattern.exec(text)) !== null) {
            matches.push({
              index: m.index,
              markerLength: m[0].length,
              title: spec.title,
            });
          }
        });

        if (!matches.length) {
          return [];
        }

        const unique = new Map();
        matches.forEach((match) => {
          const existing = unique.get(match.index);
          if (!existing || existing.markerLength < match.markerLength) {
            unique.set(match.index, match);
          }
        });
        const sorted = Array.from(unique.values()).sort((a, b) => a.index - b.index);

        const sections = [];
        for (let i = 0; i < sorted.length; i += 1) {
          const current = sorted[i];
          const next = sorted[i + 1];
          const sectionStart = current.index + current.markerLength;
          const sectionEnd = next ? next.index : text.length;
          const content = trimLeadingMetadataLines(text.slice(sectionStart, sectionEnd));
          if (content) {
            sections.push({
              title: current.title,
              content,
            });
          }
        }

        if (!sections.length) {
          return sections;
        }

        const firstIndex = sorted[0].index;
        if (firstIndex > 0) {
          const prefix = trimLeadingMetadataLines(text.slice(0, firstIndex));
          if (prefix) {
            sections.unshift({
              title: "üìù ÊñáÁ´†ÂÜÖÂÆπ",
              content: prefix,
            });
          }
        }

        return sections;
      }

      function hasPotentialSectionHeading(text) {
        const normalized = normalizeSourceText(text);
        const detectPatterns = [
          /#{1,6}\s*ü§ñ\s*AI\s*Summary/i,
          /#{1,6}\s*üí¨\s*Chat\s*History/i,
          /#{1,6}\s*üìÑ\s*(?:Original\s*Abstract|ÂéüÊñáÊëòË¶Å|Abstract|ÊëòË¶Å)/i,
          /#{1,6}\s*üìù\s*TLDR/i,
          /#{1,6}\s*üß≠\s*ÈÄüËßàÂå∫/i,
          /#{1,6}\s*üß©\s*ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªì(?:Âå∫|ÔºàËá™Âä®ÁîüÊàêÔºâ)?/i,
          /#{1,6}\s*AI\s*Summary/i,
          /#{1,6}\s*Chat\s*History/i,
          /#{1,6}\s*(?:Original\s*Abstract|ÂéüÊñáÊëòË¶Å|Abstract|ÊëòË¶Å)/i,
          /#{1,6}\s*TLDR/i,
          /#{1,6}\s*ÈÄüËßàÂå∫/i,
          /#{1,6}\s*ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªì(?:Âå∫|ÔºàËá™Âä®ÁîüÊàêÔºâ)?/i,
        ];
        return detectPatterns.some((pattern) => pattern.test(normalized));
      }

      function splitSectionsByMarkers(fullText) {
        const cleaned = normalizeSourceText(fullText);
        const marks = [
          { marker: MARKER_SUMMARY, title: "ü§ñ AI Summary" },
          { marker: MARKER_CHAT, title: "üí¨ Chat History" },
          { marker: MARKER_ORIG, title: "üìÑ Original Abstract" },
          { marker: MARKER_TLDR, title: "üìù TLDR" },
          { marker: MARKER_GLANCE, title: "üß≠ ÈÄüËßàÂå∫" },
          { marker: MARKER_GLANCE_LEGACY, title: "üß≠ ÈÄüËßàÂå∫" },
          { marker: MARKER_DETAIL, title: "üß© ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªìÂå∫" },
          { marker: MARKER_DETAIL_LEGACY, title: "üß© ËÆ∫ÊñáËØ¶ÁªÜÊÄªÁªìÂå∫" },
        ];
        const matched = marks
          .map((m) => ({
            marker: m.marker,
            title: m.title,
            index: cleaned.indexOf(m.marker),
          }))
          .filter((item) => item.index > -1)
          .sort((a, b) => a.index - b.index);

        if (!matched.length) {
          return [];
        }

        const result = [];
        for (let i = 0; i < matched.length; i += 1) {
          const current = matched[i];
          const nextIndex =
            i + 1 < matched.length ? matched[i + 1].index : cleaned.length;
          const rawSection = cleaned.substring(
            current.index + current.marker.length,
            nextIndex,
          );
          const content = trimLeadingMetadataLines(rawSection);
          if (!content) {
            continue;
          }
          result.push({ title: current.title, content });
          if (i === 0 && current.index > 0) {
            const prefix = trimLeadingMetadataLines(cleaned.substring(0, current.index));
            if (prefix) {
              result.unshift({ title: "üìù ÊñáÁ´†ÂÜÖÂÆπ", content: prefix });
            }
          }
        }
        return result;
      }

      function dedupeSections(sections) {
        const output = [];
        const seenSignatures = new Set();

        for (const section of sections) {
          const rawTitle = normalizeText(section.title || "üìù ÊñáÁ´†ÂÜÖÂÆπ");
          const title = canonicalizeSectionTitle(rawTitle);
          const content = trimLeadingMetadataLines(section.content || "");
          if (!content) {
            continue;
          }
          const c = normalizeSectionFingerprint(content);
          const t = normalizeTitleKey(title);
          const signature = `${t}|||${c}`;
          if (seenSignatures.has(signature)) {
            continue;
          }
          seenSignatures.add(signature);
          output.push({
            title: title || rawTitle,
            content,
          });
        }
        return output;
      }

      function splitSections(fullText) {
        const cleaned = normalizeSourceText(fullText);
        if (!cleaned) {
          return {
            valid: false,
            reason: "‚ö†Ô∏è Êù°ÁõÆÊëòË¶Å‰∏∫Á©∫ÔºåÁ≠âÂæÖÈáçËØï‰∏≠„ÄÇ",
          };
        }

        const markerSections = splitSectionsByMarkers(cleaned);
        if (markerSections.length) {
          const segments = dedupeSections(markerSections);
          if (segments.length) {
            return {
              valid: true,
              sections: segments,
            };
          }
        }

        const markdownSections = splitSectionsByKnownMarkdownHeadings(cleaned);
        if (markdownSections.length) {
          const segments = dedupeSections(markdownSections);
          if (segments.length) {
            return {
              valid: true,
              sections: segments,
            };
          }
        }

        const lines = cleaned.split("\n");
        const parsedSections = [];
        let currentTitle = "üìù ÊñáÁ´†ÂÜÖÂÆπ";
        let currentBuffer = [];

        const flush = () => {
          const title = canonicalizeSectionTitle(currentTitle);
          const content = trimLeadingMetadataLines(currentBuffer.join("\n"));
          if (content) {
            parsedSections.push({
              title,
              content,
            });
          }
          currentBuffer = [];
        };

        for (const rawLine of lines) {
          if (isSectionHeading(rawLine)) {
            flush();
            const heading = normalizeSectionTitle(rawLine);
            currentTitle = heading || currentTitle;
            continue;
          }
          currentBuffer.push(rawLine);
        }
        flush();

        const sections = dedupeSections(parsedSections);
        if (
          sections.length === 1 &&
          normalizeSectionTitle(sections[0].title) === "üìù ÊñáÁ´†ÂÜÖÂÆπ"
        ) {
          const fallbackMarkdownSections = splitSectionsByKnownMarkdownHeadings(
            sections[0].content,
          );
          if (
            fallbackMarkdownSections.length > 1 &&
            hasPotentialSectionHeading(sections[0].content)
          ) {
            return {
              valid: true,
              sections: dedupeSections(fallbackMarkdownSections),
            };
          }
          if (fallbackMarkdownSections.length > 1 && hasAnyMarker(sections[0].content)) {
            return {
              valid: true,
              sections: dedupeSections(fallbackMarkdownSections),
            };
          }
        }

        if (!sections.length) {
          return {
            valid: true,
            sections: [{ title: "üìù ÊñáÁ´†ÂÜÖÂÆπ", content: cleaned }],
          };
        }

        return {
          valid: true,
          sections,
        };
      }

      function collectItemMetadata(targetItem) {
        const creators = targetItem.getCreators ? targetItem.getCreators() : [];
        const authorTexts = creators
          .map((author) => {
            const part =
              normalizeText(author.lastName) ||
              normalizeText(author.name) ||
              normalizeText(author.fieldMode) ||
              "";
            const display = normalizeText(author.firstName)
              ? `${part} ${normalizeText(author.firstName)}`
              : part;
            return display.trim();
          })
          .filter(Boolean);

        const tags = targetItem.getTags ? targetItem.getTags() : [];
        const tagTexts = tags
          .map((t) => normalizeText(t.tag).trim())
          .filter(Boolean);

        const metadataItems = [
          ["Ê†áÈ¢ò", normalizeText(targetItem.getField("title"))],
          ["‰ΩúËÄÖ", authorTexts.join("Ôºõ")],
          ["ÂèëË°®Âπ¥‰ªΩ", normalizeText(targetItem.getField("year"))],
          ["Êó•Êúü", normalizeText(targetItem.getField("date"))],
          ["ÊúüÂàä", normalizeText(targetItem.getField("publicationTitle"))],
          ["Âá∫ÁâàÁ§æ", normalizeText(targetItem.getField("publisher"))],
          ["DOI", normalizeText(targetItem.getField("DOI"))],
          ["ÊñáÁ´†Á±ªÂûã", normalizeText(targetItem.getField("itemType"))],
          ["URL", normalizeText(targetItem.getField("url"))],
          ["Ê†áÁ≠æ", tagTexts.join("Ôºõ")],
        ].filter((tuple) => tuple[1]);

        if (!metadataItems.length && !authorTexts.length && !tagTexts.length) {
          return "";
        }

        const lines = [];
        metadataItems.forEach(([k, v]) => {
          lines.push(`- **${k}**: ${normalizeText(v)}`);
        });
        return lines.join("\n");
      }

      function formatChatMarkdown(rawChatString) {
        if (!rawChatString) {
          return "";
        }
        const segments = rawChatString.split(/(?=üë§ User:|ü§ñ AI:)/g);
        const lines = [];
        for (const seg of segments) {
          const cleanText = normalizeSourceText(seg).trim();
          if (!cleanText) {
            continue;
          }
          if (cleanText.startsWith("üë§ User:")) {
            lines.push(`**üë§ User:**\n${cleanText.replace("üë§ User:", "").trim()}`);
          } else if (cleanText.startsWith("ü§ñ AI:")) {
            lines.push(`**ü§ñ AI:**\n${cleanText.replace("ü§ñ AI:", "").trim()}`);
          }
        }
        return lines.join("\n\n");
      }

      function buildNoteMarkdown(targetItem, parsed) {
        const blocks = [];
        const rawText = parsed && parsed.rawText ? normalizeSourceText(parsed.rawText) : "";
        const addBlock = (title, content) => {
          if (!content) return;
          blocks.push(`## ${title}`);
          blocks.push(content);
        };

        const stripLeadingHeading = (text, title) => {
          const escaped = title.replace(
            /[.*+?^${}()|[\]\\]/g,
            "\\$&",
          );
          return text
            .replace(
              new RegExp(`^\\s*#{1,6}\\s*${escaped}\\s*\\n+`, "i"),
              "",
            )
            .trim();
        };

        const metadata = collectItemMetadata(targetItem);
        if (metadata) {
          addBlock("üìã ÊñáÁ´†ÂÖÉ‰ø°ÊÅØ", metadata);
        }

        const sections = parsed.sections || [];
        const hasChat = sections.some((item) => /chat history|üí¨/i.test(item.title));
        const ignoredSectionTitleSet = new Set(["È°µÈù¢ÂØºËà™‰∏é‰∫§‰∫íÂ±Ç", "üìù ËÆ∫ÊñáÊ≠£Êñá"]);
        sections.forEach((section) => {
          const title = normalizeText(section.title || "üìù ÊñáÁ´†ÂÜÖÂÆπ");
          let content = trimLeadingMetadataLines(section.content);
          if (!content) {
            return;
          }
          if (ignoredSectionTitleSet.has(title)) {
            return;
          }

          if (/chat history|üí¨/i.test(title)) {
            content = formatChatMarkdown(content) || content;
          }
          addBlock(title, content);
        });

        if (!sections.length) {
          addBlock("üìù ÊñáÁ´†ÂÜÖÂÆπ", "ÔºàÊó†ÂèØËß£ÊûêÂÜÖÂÆπÔºâ");
        }

        if (!hasChat && rawText && rawText.includes("üí¨ Chat History")) {
          const markerStart = normalizeSourceText(parsed.rawText).indexOf(MARKER_CHAT);
          if (markerStart > -1) {
            const markerChat = normalizeSourceText(parsed.rawText).substring(
              markerStart + MARKER_CHAT.length,
            );
            addBlock("üí¨ Chat History", formatChatMarkdown(markerChat));
          }
        }

        return blocks.join("\n\n");
      }

      function markdownToPlainHtml(markdownText) {
        const lines = normalizeText(markdownText).split(/\n/);
        const htmlParts = [];
        let paragraphBuffer = [];
        let listType = "";
        let listItems = [];

        const renderInline = (text) => {
          const escaped = escapeHtml(text);
          return escaped
            .replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>")
            .replace(/\*([^*]+)\*/g, "<em>$1</em>")
            .replace(/`([^`]+)`/g, "<code>$1</code>")
            .replace(/\n/g, "<br>");
        };

        const flushParagraph = () => {
          if (!paragraphBuffer.length) {
            return;
          }
          const blockText = paragraphBuffer.join("\n").trim();
          if (!blockText) {
            paragraphBuffer = [];
            return;
          }
          const headingMatch = blockText.match(/^(#{1,6})\s+(.*)$/);
          if (headingMatch) {
            const level = Math.min(6, headingMatch[1].length);
            htmlParts.push(
              `<h${level} style=\"margin: 14px 0 8px 0; color:#0277bd; border-bottom:1px solid #e3f2fd;\">${renderInline(
                headingMatch[2],
              )}</h${level}>`,
            );
          } else if (/^\s*>\s*/.test(blockText)) {
            htmlParts.push(
              `<blockquote style=\"margin: 12px 0; padding-left: 12px; color:#666; border-left: 3px solid #bbdefb; white-space: pre-wrap;\">${renderInline(
                blockText.replace(/^\s*>\s*/, ""),
              )}</blockquote>`,
            );
          } else {
            htmlParts.push(
              `<p style=\"display:block; color: #333; font-size: 1em; line-height: 1.6; white-space: pre-wrap; margin: 0 0 12px 0;\">${renderInline(
                blockText,
              )}</p>`,
            );
          }
          paragraphBuffer = [];
        };

        const flushList = () => {
          if (!listType || !listItems.length) {
            listType = "";
            listItems = [];
            return;
          }
          const wrappedItems = listItems.map((item) => `<li>${renderInline(item)}</li>`).join("");
          if (listType === "ol") {
            htmlParts.push(
              `<ol style=\"margin: 8px 0 12px 0; padding-left: 24px;\">${wrappedItems}</ol>`,
            );
          } else {
            htmlParts.push(
              `<ul style=\"margin: 8px 0 12px 0; padding-left: 24px;\">${wrappedItems}</ul>`,
            );
          }
          listType = "";
          listItems = [];
        };

        const flushAll = () => {
          flushParagraph();
          flushList();
        };

        const orderedMatch = (line) => /^\s{0,3}\d+\.\s+(.*)$/.exec(line);
        const unorderedMatch = (line) => /^\s{0,3}[-*+]\s+(.*)$/.exec(line);

        for (const line of lines) {
          const headingLine = line.match(/^(#{1,6})\s+(.*)$/);
          if (headingLine) {
            flushAll();
            const level = Math.min(6, headingLine[1].length);
            htmlParts.push(
              `<h${level} style=\"margin: 14px 0 8px 0; color:#0277bd; border-bottom:1px solid #e3f2fd;\">${renderInline(
                headingLine[2],
              )}</h${level}>`,
            );
            continue;
          }

          if (/^\s*>\s*/.test(line)) {
            flushAll();
            htmlParts.push(
              `<blockquote style=\"margin: 12px 0; padding-left: 12px; color:#666; border-left: 3px solid #bbdefb; white-space: pre-wrap;\">${renderInline(
                line.replace(/^\s*>\s*/, ""),
              )}</blockquote>`,
            );
            continue;
          }

          const ordered = orderedMatch(line);
          if (ordered) {
            flushParagraph();
            if (listType !== "ol") {
              flushList();
              listType = "ol";
            }
            listItems.push(ordered[1]);
            continue;
          }

          const unordered = unorderedMatch(line);
          if (unordered) {
            flushParagraph();
            if (listType !== "ul") {
              flushList();
              listType = "ul";
            }
            listItems.push(unordered[1]);
            continue;
          }

          if (!line.trim()) {
            flushAll();
            continue;
          }
          flushList();
          paragraphBuffer.push(line);
        }
        flushAll();

        return `<div style="font-family: -apple-system, BlinkMacSystemFont, sans-serif; color: #333; line-height: 1.6;">${htmlParts
          .filter(Boolean)
          .join("")}</div>`;
      }

      function hasAutoSummaryNote(targetItem) {
        try {
          const notes = Zotero.Items.get(targetItem.getNotes()) || [];
          return notes.some((note) => {
            const tags = note.getTags ? note.getTags() : [];
            if (tags?.some((tagItem) => tagItem.tag === AUTO_NOTE_TAG)) {
              return true;
            }
            const title = normalizeText(note.getNoteTitle ? note.getNoteTitle() : "")
              .toLowerCase();
            if (title.includes("ai summary") || title.includes("daily-paper")) {
              return true;
            }
            const noteHtml = normalizeText(note.getNote()).toLowerCase();
            return (
              noteHtml.includes("ü§ñ ai summary") ||
              noteHtml.includes("üìÑ original abstract") ||
              noteHtml.includes("dpr-ai-summary-note")
            );
          });
        } catch (err) {
          return false;
        }
      }

      function hasLatexFormula(content) {
        const text = normalizeSourceText(content || "");
        return /\${1,2}[^$]+?\${1,2}/.test(text);
      }

      function normalizeRenderedHtml(html) {
        return normalizeText(html)
          .replace(/<strong>/gi, "<b>")
          .replace(/<\/strong>/gi, "</b>")
          .replace(/<em>/gi, "<i>")
          .replace(/<\/em>/gi, "</i>");
      }

      async function removeAutoSummaryNotes(targetItem) {
        try {
          const notes = Zotero.Items.get(targetItem.getNotes()) || [];
          for (const note of notes) {
            const tags = note.getTags ? note.getTags() : [];
            const hasTag = tags?.some((tagItem) => tagItem.tag === AUTO_NOTE_TAG);
            if (!hasTag) {
              const title = normalizeText(note.getNoteTitle ? note.getNoteTitle() : "")
                .toLowerCase();
              const noteHtml = normalizeText(note.getNote()).toLowerCase();
              const isAuto =
                title.includes("ai summary") ||
                title.includes("daily-paper") ||
                noteHtml.includes("ü§ñ ai summary") ||
                noteHtml.includes("üìÑ original abstract");
              if (!isAuto) {
                continue;
              }
            }

            try {
              if (note.eraseTx) {
                await note.eraseTx();
              } else if (note.deleteTx) {
                await note.deleteTx();
              }
            } catch (err) {
              // ignore removal failure
            }
          }
        } catch (err) {
          // ignore removal process
        }
      }

      async function processItem(targetItem) {
        const title = normalizeText(targetItem.getField("title")) || "[Êó†Ê†áÈ¢ò]";

        if (hasAutoSummaryNote(targetItem)) {
          await removeAutoSummaryNotes(targetItem);
        }

        let sourceText = "";
        let sourceField = "";
        for (let i = 0; i <= RETRY_DELAYS.length; i += 1) {
          const sourceResult = getSourceText(targetItem);
          sourceText = sourceResult && sourceResult.text ? sourceResult.text : "";
          sourceField = sourceResult && sourceResult.field ? sourceResult.field : "";
          if (sourceText) {
            break;
          }
          if (triggerType === "createItem" && i < RETRY_DELAYS.length) {
            await sleep(RETRY_DELAYS[i]);
          }
        }

        if (!sourceText) {
          const failHint = sourceField
            ? `ÔºàËØªÂèñÂà∞Â≠óÊÆµ: ${sourceField}Ôºå‰ΩÜÂÜÖÂÆπ‰∏∫Á©∫Ôºâ`
            : "ÔºàÊú™Ê£ÄÊµãÂà∞ÂèØÁî®ÊëòË¶ÅÂ≠óÊÆµÔºâ";
          return `‚ö†Ô∏è [${escapeHtml(title)}] ÊöÇÊú™ËØªÂà∞ÊëòË¶ÅÔºåÂØºÂÖ•Â§±Ë¥• ${failHint}`;
        }

        const parsed = splitSections(sourceText);
        if (!parsed.valid) {
          return parsed.reason;
        }

        const noteMarkdown = buildNoteMarkdown(targetItem, {
          ...parsed,
          rawText: sourceText,
        });
        let noteHtml = "";
        const canUseBetterNotes =
          !!(
            Zotero.BetterNotes &&
            Zotero.BetterNotes.api &&
            Zotero.BetterNotes.api.convert &&
            Zotero.BetterNotes.api.convert.md2html &&
            Zotero.BetterNotes.api.note &&
            Zotero.BetterNotes.api.note.insert
          );
        const hasMathFormula = hasLatexFormula(noteMarkdown);

        if (canUseBetterNotes && !hasMathFormula) {
          try {
            noteHtml = await Zotero.BetterNotes.api.convert.md2html(noteMarkdown);
            noteHtml = normalizeRenderedHtml(noteHtml);
          } catch (err) {
            noteHtml = markdownToPlainHtml(noteMarkdown);
          }
        } else {
          noteHtml = markdownToPlainHtml(noteMarkdown);
        }

        const newNote = new Zotero.Item("note");
        newNote.libraryID = targetItem.libraryID;
        newNote.parentID = targetItem.id;
        newNote.addTag(AUTO_NOTE_TAG, 1);
        newNote.setNote(noteHtml);
        await newNote.saveTx();

        return `‚úÖ [${escapeHtml(title)}] Â∑≤Ëá™Âä®ÂàõÂª∫ AI Summary Êù°ÁõÆÁ¨îËÆ∞`;
      }

      const results = [];
      for (let i = 0; i < targetItems.length; i += 1) {
        results.push(await processItem(targetItems[i]));
      }

      return results.join("\n");
    shortcut: ''
    enabled: true
    menu: ''
    name: Process AI Summary
    showInMenu:
      item: false
      collection: false
      tools: false
      reader: false
      readerAnnotation: false
