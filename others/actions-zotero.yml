type: ActionsTagsBackup
author: zwwen0711
platformVersion: 7.0.30
pluginVersion: 2.2.4
timestamp: '2025-12-28T17:22:32.173Z'
actions:
  1766933168242-lENQeb2s:
    event: 1
    operation: 4
    data: >-
      const MARKER_SUMMARY = "ã€ğŸ¤– AI Summaryã€‘";
      const MARKER_CHAT = "ã€ğŸ’¬ Chat Historyã€‘";
      const MARKER_ORIG = "ã€ğŸ“„ Original Abstractã€‘";
      const BR_PLACEHOLDER = /__BR__/g;
      const AUTO_NOTE_TAG = "dpr-ai-summary-note";
      const RETRY_DELAYS = [300, 800, 1500];

      const targetItems = (typeof items !== "undefined" && items && items.length > 0)
        ? items
        : ((typeof item !== "undefined" && item) ? [item] : []);

      if (!targetItems || targetItems.length === 0) {
        return "âŒ é”™è¯¯ï¼šæœªæ¥æ”¶åˆ°æœ‰æ•ˆæ¡ç›®ï¼ˆè¯·å…ˆåœ¨æ¡ç›®ä¸Šè§¦å‘è„šæœ¬ï¼‰";
      }

      function normalizeText(v) {
        return (v || "").toString();
      }

      function normalizeSourceText(v) {
        const plain = normalizeText(v)
          .replace(/<br\s*\/?>/gi, "\n")
          .replace(/<\/p>/gi, "\n")
          .replace(/<p[^>]*>/gi, "")
          .replace(/<[^>]+>/g, "")
          .replace(BR_PLACEHOLDER, "\n")
          .replace(/\r/g, "\n");
        return plain
          .replace(/\n{3,}/g, "\n\n")
          .trim();
      }

      function escapeHtml(v) {
        return normalizeText(v)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function getFieldSafe(targetItem, fieldName) {
        try {
          return normalizeText(targetItem.getField(fieldName));
        } catch (err) {
          return "";
        }
      }

      function getSourceText(targetItem) {
        const candidateFields = [
          "abstractNote",
          "abstract",
          "description",
          "citation_abstract",
          "dc.description",
          "DC.description",
          "extra",
        ];
        for (const fieldName of candidateFields) {
          const raw = normalizeSourceText(getFieldSafe(targetItem, fieldName));
          if (raw) {
            return raw;
          }
        }
        return "";
      }

      function classifySectionTitle(title) {
        const raw = normalizeText(title).toLowerCase().trim();
        if (
          raw.includes("è®ºæ–‡è¯¦ç»†æ€»ç»“") ||
          raw.includes("ğŸ¤– ai summary") ||
          raw.includes("ai summary") ||
          (raw.includes("summary") && !raw.includes("original"))
        ) {
          return "summary";
        }
        if (raw.includes("chat history") || raw.includes("ğŸ’¬ chat history")) {
          return "chat";
        }
        if (
          raw.includes("original abstract") ||
          raw.includes("ğŸ“„ original abstract") ||
          raw.includes("åŸæ–‡æ‘˜è¦") ||
          (raw.includes("æ‘˜è¦") && !raw.includes("è¯¦ç»†") && !raw.includes("åŸæ–‡"))
        ) {
          return "original";
        }
        return "other";
      }

      function trimLeadingMetadataLines(text) {
        const lines = normalizeSourceText(text).split("\n");
        const filtered = [];
        let started = false;
        const skipExact = new Set([
          MARKER_SUMMARY,
          MARKER_CHAT,
          MARKER_ORIG,
          "## ğŸ¤– AI Summary",
          "## ğŸ“„ Original Abstract",
          "## ğŸ’¬ Chat History",
          "## è®ºæ–‡è¯¦ç»†æ€»ç»“",
          "## è®ºæ–‡è¯¦ç»†æ€»ç»“ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰",
        ]);
        for (const line of lines) {
          const t = line.trim();
          if (!started && (t === "" || skipExact.has(t))) {
            continue;
          }
          if (
            !started &&
            /^#{1,6}\s+/.test(t) &&
            (
              /\bAI Summary\b/i.test(t) ||
              /\bOriginal Abstract\b/i.test(t) ||
              /\bChat History\b/i.test(t) ||
              t.includes("è®ºæ–‡è¯¦ç»†æ€»ç»“")
            )
          ) {
            continue;
          }
          if (t.startsWith("Tags:")) {
            continue;
          }
          if (/^> ç”± daily-paper-reader è‡ªåŠ¨ç”Ÿæˆ/.test(t)) {
            continue;
          }
          started = true;
          filtered.push(t);
        }
        return filtered
          .join("\n")
          .replace(/\n{3,}/g, "\n\n")
          .trim();
      }

      function splitByHeadings(text) {
        const lines = normalizeSourceText(text).split("\n");
        const sectionMap = { summary: [], chat: [], original: [] };
        let currentType = null;
        let buffer = [];

        const flush = () => {
          if (!currentType) {
            return;
          }
          const merged = trimLeadingMetadataLines(buffer.join("\n"));
          if (merged) {
            sectionMap[currentType].push(merged);
          }
          buffer = [];
        };

        for (const rawLine of lines) {
          const line = rawLine.trim();
          const headerMatch = line.match(/^#{1,6}\s+(.*)$/);
          if (headerMatch) {
            flush();
            const kind = classifySectionTitle(headerMatch[1]);
            currentType = kind === "other" ? null : kind;
            continue;
          }

          if (currentType) {
            buffer.push(rawLine);
          }
        }
        flush();

        return sectionMap;
      }

      function pickSection(sectionMap, keys) {
        for (const key of keys) {
          const arr = sectionMap[key] || [];
          if (!arr.length) continue;
          for (let i = 0; i < arr.length; i += 1) {
            const item = trimLeadingMetadataLines(arr[i]);
            if (item) {
              return item;
            }
          }
        }
        return "";
      }

      function nextBoundary(text, startPos) {
        let best = -1;
        [MARKER_SUMMARY, MARKER_CHAT, MARKER_ORIG].forEach((marker) => {
          const pos = text.indexOf(marker, startPos);
          if (pos > -1 && (best === -1 || pos < best)) {
            best = pos;
          }
        });
        return best === -1 ? text.length : best;
      }

      function splitByMarkers(text) {
        const s = text.indexOf(MARKER_SUMMARY);
        const c = text.indexOf(MARKER_CHAT);
        const o = text.indexOf(MARKER_ORIG);
        if (s === -1 && c === -1 && o === -1) {
          return {
            summary: trimLeadingMetadataLines(text),
            chat: "",
            original: "",
            hasMarkers: false,
          };
        }

        const summaryStart = s === -1 ? -1 : s + MARKER_SUMMARY.length;
        const chatStart = c === -1 ? -1 : c + MARKER_CHAT.length;
        const originalStart = o === -1 ? -1 : o + MARKER_ORIG.length;

        return {
          summary:
            s === -1
              ? ""
              : trimLeadingMetadataLines(
                  text.substring(summaryStart, nextBoundary(text, summaryStart)),
                ),
          chat:
            c === -1
              ? ""
              : trimLeadingMetadataLines(
                  text.substring(chatStart, nextBoundary(text, chatStart)),
                ),
          original:
            o === -1
              ? ""
              : trimLeadingMetadataLines(
                  text.substring(
                    originalStart,
                    nextBoundary(text, originalStart),
                  ),
                ),
          hasMarkers: true,
        };
      }

      function splitSections(fullText) {
        const cleaned = normalizeSourceText(fullText);
        if (!cleaned) {
          return {
            valid: false,
            reason: "âš ï¸ æ¡ç›®æ‘˜è¦ä¸ºç©ºï¼Œç­‰å¾…é‡è¯•ä¸­ã€‚",
          };
        }

        const headingParsed = splitByHeadings(cleaned);
        const parsedSummary = pickSection(headingParsed, ["summary"]);
        const parsedChat = pickSection(headingParsed, ["chat"]);
        const parsedOriginal = pickSection(headingParsed, ["original"]);

        if (parsedSummary || parsedChat || parsedOriginal) {
          return {
            valid: true,
            summary: parsedSummary,
            chat: parsedChat,
            original: parsedOriginal,
            hasMarkers: true,
          };
        }

        const markerParsed = splitByMarkers(cleaned);
        if (!markerParsed.summary && !markerParsed.chat && !markerParsed.original) {
          return {
            valid: false,
            reason: "âš ï¸ æœªæ£€æµ‹åˆ°å¯è¯†åˆ«çš„ AI æ‘˜è¦ç»“æ„ï¼Œç­‰å¾…é‡è¯•ä¸­ã€‚",
          };
        }

        return {
          valid: true,
          summary: markerParsed.summary,
          chat: markerParsed.chat,
          original: markerParsed.original,
          hasMarkers: markerParsed.hasMarkers,
        };
      }

      function formatChatMarkdown(rawChatString) {
        if (!rawChatString) {
          return "";
        }
        const segments = rawChatString.split(/(?=ğŸ‘¤ User:|ğŸ¤– AI:)/g);
        const lines = [];
        for (const seg of segments) {
          const cleanText = normalizeSourceText(seg).trim();
          if (!cleanText) {
            continue;
          }
          if (cleanText.startsWith("ğŸ‘¤ User:")) {
            lines.push(`**ğŸ‘¤ User:**\n${cleanText.replace("ğŸ‘¤ User:", "").trim()}`);
          } else if (cleanText.startsWith("ğŸ¤– AI:")) {
            lines.push(`**ğŸ¤– AI:**\n${cleanText.replace("ğŸ¤– AI:", "").trim()}`);
          }
        }
        return lines.join("\n\n");
      }

      function buildNoteMarkdown(parsed) {
        const blocks = [];
        const addBlock = (title, content) => {
          if (!content) return;
          blocks.push(`## ${title}`);
          blocks.push(content);
        };

        const stripLeadingHeading = (text, title) => {
          const escaped = title.replace(
            /[.*+?^${}()|[\]\\]/g,
            "\\$&",
          );
          return text
            .replace(
              new RegExp(`^\\s*#{1,6}\\s*${escaped}\\s*\\n+`, "i"),
              "",
            )
            .trim();
        };

        const summaryText = parsed.summary
          ? trimLeadingMetadataLines(
              stripLeadingHeading(parsed.summary, "ğŸ¤– AI Summary"),
            )
          : "";
        addBlock(
          "ğŸ¤– AI Summary",
          summaryText || "ï¼ˆæœªæ£€æµ‹åˆ° AI Summaryï¼Œå·²è‡ªåŠ¨é™çº§å±•ç¤ºåŸå§‹å†…å®¹ï¼‰",
        );

        if (parsed.chat) {
          const chatText = formatChatMarkdown(parsed.chat);
          addBlock("ğŸ’¬ Chat History", chatText);
        }
        const originalText = parsed.original
          ? trimLeadingMetadataLines(
              stripLeadingHeading(parsed.original, "ğŸ“„ Original Abstract"),
            )
          : "";
        if (originalText) {
          addBlock("ğŸ“„ Original Abstract", originalText);
        }
        return blocks.join("\n\n");
      }

      function markdownToPlainHtml(markdownText) {
        const lines = normalizeText(markdownText).split(/\n/);
        const htmlParts = [];
        let paragraphBuffer = [];
        const flushParagraph = () => {
          if (!paragraphBuffer.length) {
            return;
          }
          const blockText = paragraphBuffer.join("\n").trim();
          if (!blockText) {
            paragraphBuffer = [];
            return;
          }
          const headingMatch = blockText.match(/^(#{1,6})\s+(.*)$/);
          if (headingMatch) {
            const level = Math.min(6, headingMatch[1].length);
            htmlParts.push(
              `<h${level} style=\"margin: 14px 0 8px 0; color:#0277bd; border-bottom:1px solid #e3f2fd;\">${escapeHtml(
                headingMatch[2],
              )}</h${level}>`,
            );
          } else if (/^\s*>\s*/.test(blockText)) {
            htmlParts.push(
              `<blockquote style=\"margin: 12px 0; padding-left: 12px; color:#666; border-left: 3px solid #bbdefb; white-space: pre-wrap;\">${escapeHtml(
                blockText.replace(/^\s*>\s*/, ""),
              ).replace(/\n/g, "<br>")}</blockquote>`,
            );
          } else {
            const esc = escapeHtml(blockText).replace(/\n/g, "<br>");
            htmlParts.push(
              `<p style=\"display:block; color: #333; font-size: 1em; line-height: 1.6; white-space: pre-wrap; margin: 0 0 12px 0;\">${esc}</p>`,
            );
          }
          paragraphBuffer = [];
        };

        for (const line of lines) {
          if (!line.trim()) {
            flushParagraph();
            continue;
          }
          paragraphBuffer.push(line);
        }
        flushParagraph();

        return `<div style="font-family: -apple-system, BlinkMacSystemFont, sans-serif; color: #333; line-height: 1.6;">${htmlParts
          .filter(Boolean)
          .join("")}</div>`;
      }

      function hasAutoSummaryNote(targetItem) {
        try {
          const notes = Zotero.Items.get(targetItem.getNotes()) || [];
          return notes.some((note) => {
            const tags = note.getTags ? note.getTags() : [];
            if (tags?.some((tagItem) => tagItem.tag === AUTO_NOTE_TAG)) {
              return true;
            }
            const title = normalizeText(note.getNoteTitle ? note.getNoteTitle() : "")
              .toLowerCase();
            return title.includes("ai summary") || title.includes("daily-paper");
          });
        } catch (err) {
          return false;
        }
      }

      async function processItem(targetItem) {
        const title = normalizeText(targetItem.getField("title")) || "[æ— æ ‡é¢˜]";

        if (hasAutoSummaryNote(targetItem)) {
          return `â„¹ï¸ [${escapeHtml(title)}] å·²å­˜åœ¨æ‘˜è¦ç¬”è®°ï¼Œå·²è·³è¿‡`;
        }

        let sourceText = "";
        for (let i = 0; i <= RETRY_DELAYS.length; i += 1) {
          sourceText = getSourceText(targetItem);
          if (sourceText) {
            break;
          }
          if (triggerType === "createItem" && i < RETRY_DELAYS.length) {
            await sleep(RETRY_DELAYS[i]);
          }
        }

        if (!sourceText) {
          return `âš ï¸ [${escapeHtml(title)}] æš‚æœªè¯»åˆ°æ‘˜è¦ï¼Œå¯¼å…¥å¤±è´¥`;
        }

        const parsed = splitSections(sourceText);
        if (!parsed.valid) {
          return parsed.reason;
        }

        const noteMarkdown = buildNoteMarkdown(parsed);
        let noteHtml = "";
        const canUseBetterNotes =
          !!(
            Zotero.BetterNotes &&
            Zotero.BetterNotes.api &&
            Zotero.BetterNotes.api.convert &&
            Zotero.BetterNotes.api.convert.md2html &&
            Zotero.BetterNotes.api.note &&
            Zotero.BetterNotes.api.note.insert
          );

        if (canUseBetterNotes) {
          try {
            noteHtml = await Zotero.BetterNotes.api.convert.md2html(noteMarkdown);
          } catch (err) {
            noteHtml = markdownToPlainHtml(noteMarkdown);
          }
        } else {
          noteHtml = markdownToPlainHtml(noteMarkdown);
        }

        const newNote = new Zotero.Item("note");
        newNote.libraryID = targetItem.libraryID;
        newNote.parentID = targetItem.id;
        newNote.addTag(AUTO_NOTE_TAG, 1);
        newNote.setNote(noteHtml);
        await newNote.saveTx();

        if (canUseBetterNotes && Zotero.BetterNotes?.api?.note?.insert) {
          try {
            await Zotero.BetterNotes.api.note.insert(newNote, noteHtml, -1);
          } catch (err) {
            // fallback to standard note API
          }
        }

        if (parsed.original) {
          targetItem.setField(
            "abstractNote",
            normalizeText(parsed.original).replace(BR_PLACEHOLDER, "\n"),
          );
          await targetItem.saveTx();
        }

        return `âœ… [${escapeHtml(title)}] å·²è‡ªåŠ¨åˆ›å»º AI Summary æ¡ç›®ç¬”è®°`;
      }

      const results = [];
      for (let i = 0; i < targetItems.length; i += 1) {
        results.push(await processItem(targetItems[i]));
      }

      return results.join("\n");
    shortcut: ''
    enabled: true
    menu: ''
    name: Process AI Summary
    showInMenu:
      item: false
      collection: false
      tools: false
      reader: false
      readerAnnotation: false
