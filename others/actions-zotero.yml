type: ActionsTagsBackup
author: zwwen0711
platformVersion: 7.0.30
pluginVersion: 2.2.4
timestamp: '2025-12-28T17:22:32.173Z'
actions:
  1766933168242-lENQeb2s:
    event: 1
    operation: 4
    data: >-
      const MARKER_SUMMARY = "ã€ğŸ¤– AI Summaryã€‘";
      const MARKER_CHAT = "ã€ğŸ’¬ Chat Historyã€‘";
      const MARKER_ORIG = "ã€ğŸ“„ Original Abstractã€‘";
      const BR_PLACEHOLDER = /__BR__/g;
      const AUTO_NOTE_TAG = "dpr-ai-summary-note";
      const RETRY_DELAYS = [300, 800, 1500];

      const targetItems = (typeof items !== "undefined" && items && items.length > 0)
        ? items
        : ((typeof item !== "undefined" && item) ? [item] : []);

      if (!targetItems || targetItems.length === 0) {
        return "âŒ é”™è¯¯ï¼šæœªæ¥æ”¶åˆ°æœ‰æ•ˆæ¡ç›®ï¼ˆè¯·å…ˆåœ¨æ¡ç›®ä¸Šè§¦å‘è„šæœ¬ï¼‰";
      }

      function normalizeText(v) {
        return (v || "").toString();
      }

      function normalizeSourceText(v) {
        const plain = normalizeText(v)
          .replace(/<br\s*\/?>/gi, "\n")
          .replace(/<\\/p>/gi, "\n")
          .replace(/<p[^>]*>/gi, "")
          .replace(/<[^>]+>/g, "")
          .replace(BR_PLACEHOLDER, "\n")
          .replace(/\r/g, "\n");
        return plain
          .replace(/\n{3,}/g, "\n\n")
          .trim();
      }

      function escapeHtml(v) {
        return normalizeText(v)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function getFieldSafe(targetItem, fieldName) {
        try {
          return normalizeText(targetItem.getField(fieldName));
        } catch (err) {
          return "";
        }
      }

      function getSourceText(targetItem) {
        const candidateFields = [
          "abstractNote",
          "abstract",
          "description",
          "citation_abstract",
          "dc.description",
          "DC.description",
          "extra",
        ];
        for (const fieldName of candidateFields) {
          const raw = normalizeSourceText(getFieldSafe(targetItem, fieldName));
          if (raw) {
            return raw;
          }
        }
        return "";
      }

      function splitSections(fullText) {
        const cleaned = normalizeSourceText(fullText);
        if (!cleaned) {
          return {
            valid: false,
            reason: "âš ï¸ æ¡ç›®æ‘˜è¦ä¸ºç©ºï¼Œç­‰å¾…é‡è¯•ä¸­ã€‚",
          };
        }
        const s = cleaned.indexOf(MARKER_SUMMARY);
        const c = cleaned.indexOf(MARKER_CHAT);
        const o = cleaned.indexOf(MARKER_ORIG);

        if (s === -1 && c === -1 && o === -1) {
          return {
            valid: true,
            summary: cleaned,
            chat: "",
            original: "",
            hasMarkers: false,
          };
        }

        const summaryStart = s === -1 ? 0 : s + MARKER_SUMMARY.length;
        const summaryEnd = c > -1 ? c : o > -1 ? o : cleaned.length;
        const chatStart = c > -1 ? c + MARKER_CHAT.length : -1;
        const chatEnd = o > -1 ? o : cleaned.length;

        return {
          valid: true,
          summary: cleaned.substring(summaryStart, summaryEnd).trim(),
          chat: chatStart > -1 ? cleaned.substring(chatStart, chatEnd).trim() : "",
          original:
            o > -1 ? cleaned.substring(o + MARKER_ORIG.length).trim() : "",
          hasMarkers: s > -1 || c > -1 || o > -1,
        };
      }

      function formatChatMarkdown(rawChatString) {
        if (!rawChatString) {
          return "";
        }
        const segments = rawChatString.split(/(?=ğŸ‘¤ User:|ğŸ¤– AI:)/g);
        const lines = [];
        for (const seg of segments) {
          const cleanText = normalizeSourceText(seg).trim();
          if (!cleanText) {
            continue;
          }
          if (cleanText.startsWith("ğŸ‘¤ User:")) {
            lines.push(`**ğŸ‘¤ User:**\n${cleanText.replace("ğŸ‘¤ User:", "").trim()}`);
          } else if (cleanText.startsWith("ğŸ¤– AI:")) {
            lines.push(`**ğŸ¤– AI:**\n${cleanText.replace("ğŸ¤– AI:", "").trim()}`);
          }
        }
        return lines.join("\n\n");
      }

      function buildNoteMarkdown(parsed) {
        const blocks = [];
        blocks.push("## ğŸ¤– AI Summary");
        blocks.push(
          parsed.summary
            ? parsed.summary
            : "ï¼ˆæœªæ£€æµ‹åˆ° AI Summaryï¼Œå·²è‡ªåŠ¨é™çº§å±•ç¤ºåŸå§‹å†…å®¹ï¼‰",
        );
        if (parsed.chat) {
          const chatText = formatChatMarkdown(parsed.chat);
          if (chatText) {
            blocks.push("## ğŸ’¬ Chat History");
            blocks.push(chatText);
          }
        }
        if (parsed.original) {
          blocks.push("## ğŸ“„ Original Abstract");
          blocks.push(parsed.original);
        }
        blocks.push("\n> ç”± daily-paper-reader è‡ªåŠ¨ç”Ÿæˆ");
        return blocks.join("\n\n");
      }

      function markdownToPlainHtml(markdownText) {
        const lines = normalizeText(markdownText).split(/\n/);
        const htmlParts = [];
        let paragraphBuffer = [];
        const flushParagraph = () => {
          if (!paragraphBuffer.length) {
            return;
          }
          const blockText = paragraphBuffer.join("\n").trim();
          if (!blockText) {
            paragraphBuffer = [];
            return;
          }
          const headingMatch = blockText.match(/^(#{1,6})\s+(.*)$/);
          if (headingMatch) {
            const level = Math.min(6, headingMatch[1].length);
            htmlParts.push(
              `<h${level} style=\"margin: 14px 0 8px 0; color:#0277bd; border-bottom:1px solid #e3f2fd;\">${escapeHtml(
                headingMatch[2],
              )}</h${level}>`,
            );
          } else if (/^\s*>\s*/.test(blockText)) {
            htmlParts.push(
              `<blockquote style=\"margin: 12px 0; padding-left: 12px; color:#666; border-left: 3px solid #bbdefb; white-space: pre-wrap;\">${escapeHtml(
                blockText.replace(/^\s*>\s*/, ""),
              ).replace(/\n/g, "<br>")}</blockquote>`,
            );
          } else {
            const esc = escapeHtml(blockText).replace(/\n/g, "<br>");
            htmlParts.push(
              `<p style=\"display:block; color: #333; font-size: 1em; line-height: 1.6; white-space: pre-wrap; margin: 0 0 12px 0;\">${esc}</p>`,
            );
          }
          paragraphBuffer = [];
        };

        for (const line of lines) {
          if (!line.trim()) {
            flushParagraph();
            continue;
          }
          paragraphBuffer.push(line);
        }
        flushParagraph();

        return `<div style="font-family: -apple-system, BlinkMacSystemFont, sans-serif; color: #333; line-height: 1.6;">${htmlParts
          .filter(Boolean)
          .join("")}</div>`;
      }

      function hasAutoSummaryNote(targetItem) {
        try {
          const notes = Zotero.Items.get(targetItem.getNotes()) || [];
          return notes.some((note) => {
            const tags = note.getTags ? note.getTags() : [];
            if (tags?.some((tagItem) => tagItem.tag === AUTO_NOTE_TAG)) {
              return true;
            }
            const title = normalizeText(note.getNoteTitle ? note.getNoteTitle() : "")
              .toLowerCase();
            return title.includes("ai summary") || title.includes("daily-paper");
          });
        } catch (err) {
          return false;
        }
      }

      async function processItem(targetItem) {
        const title = normalizeText(targetItem.getField("title")) || "[æ— æ ‡é¢˜]";

        if (hasAutoSummaryNote(targetItem)) {
          return `â„¹ï¸ [${escapeHtml(title)}] å·²å­˜åœ¨æ‘˜è¦ç¬”è®°ï¼Œå·²è·³è¿‡`;
        }

        let sourceText = "";
        for (let i = 0; i <= RETRY_DELAYS.length; i += 1) {
          sourceText = getSourceText(targetItem);
          if (sourceText) {
            break;
          }
          if (triggerType === "createItem" && i < RETRY_DELAYS.length) {
            await sleep(RETRY_DELAYS[i]);
          }
        }

        if (!sourceText) {
          return `âš ï¸ [${escapeHtml(title)}] æš‚æœªè¯»åˆ°æ‘˜è¦ï¼Œå¯¼å…¥å¤±è´¥`;
        }

        const parsed = splitSections(sourceText);
        if (!parsed.valid) {
          return parsed.reason;
        }

        const noteMarkdown = buildNoteMarkdown(parsed);
        let noteHtml = "";
        const canUseBetterNotes =
          !!(
            Zotero.BetterNotes &&
            Zotero.BetterNotes.api &&
            Zotero.BetterNotes.api.convert &&
            Zotero.BetterNotes.api.convert.md2html &&
            Zotero.BetterNotes.api.note &&
            Zotero.BetterNotes.api.note.insert
          );

        if (canUseBetterNotes) {
          try {
            noteHtml = await Zotero.BetterNotes.api.convert.md2html(noteMarkdown);
          } catch (err) {
            noteHtml = markdownToPlainHtml(noteMarkdown);
          }
        } else {
          noteHtml = markdownToPlainHtml(noteMarkdown);
        }

        const newNote = new Zotero.Item("note");
        newNote.libraryID = targetItem.libraryID;
        newNote.parentID = targetItem.id;
        newNote.addTag(AUTO_NOTE_TAG, 1);
        newNote.setNote(noteHtml);
        await newNote.saveTx();

        if (canUseBetterNotes && Zotero.BetterNotes?.api?.note?.insert) {
          try {
            await Zotero.BetterNotes.api.note.insert(newNote, noteHtml, -1);
          } catch (err) {
            // fallback to standard note API
          }
        }

        if (parsed.original) {
          targetItem.setField(
            "abstractNote",
            normalizeText(parsed.original).replace(BR_PLACEHOLDER, "\n"),
          );
          await targetItem.saveTx();
        }

        return `âœ… [${escapeHtml(title)}] å·²è‡ªåŠ¨åˆ›å»º AI Summary æ¡ç›®ç¬”è®°`;
      }

      const results = [];
      for (let i = 0; i < targetItems.length; i += 1) {
        results.push(await processItem(targetItems[i]));
      }

      return results.join("\n");
    shortcut: ''
    enabled: true
    menu: ''
    name: Process AI Summary
    showInMenu:
      item: false
      collection: false
      tools: false
      reader: false
      readerAnnotation: false
