type: ActionsTagsBackup
author: zwwen0711
platformVersion: 7.0.30
pluginVersion: 2.2.4
timestamp: '2025-12-28T17:22:32.173Z'
actions:
  1766933168242-lENQeb2s:
    event: 1
    operation: 4
    data: >-
      // === 1. å®šä¹‰æ ‡è®° ===
    
      const MARKER_SUMMARY = "ã€ğŸ¤– AI Summaryã€‘";

      const MARKER_CHAT = "ã€ğŸ’¬ Chat Historyã€‘";

      const MARKER_ORIG = "ã€ğŸ“„ Original Abstractã€‘";


      // å‰ç«¯ä¼ æ¥çš„å ä½ç¬¦

      const BR_PLACEHOLDER = /__BR__/g; 


      // === 2. è·å–æ¡ç›®ï¼ˆæ”¯æŒ item / itemsï¼‰===

      const targetItems = (typeof items !== 'undefined' && items && items.length > 0)
          ? items
          : ((typeof item !== 'undefined') ? [item] : []);


      if (!targetItems || targetItems.length === 0) {
          return "âŒ é”™è¯¯ï¼šæœªæ¥æ”¶åˆ°æœ‰æ•ˆæ¡ç›® (è¯·ç¡®ä¿é€‰ä¸­äº†æ¡ç›®)";
      }


      // === 3. å·¥å…·å‡½æ•° ===

      function normalizeText(v) {
          return (v || "").toString();
      }


      function normalizeSourceText(v) {
          const plain = normalizeText(v)
              .replace(/<br\s*\/?/gi, "\n")
              .replace(/<\/p>/gi, "\n")
              .replace(/<p[^>]*>/gi, "")
              .replace(/<[^>]+>/g, "")
              .replace(/\r/g, "\n");

          return plain
              .replace(/\n{3,}/g, "\n\n")
              .trim();
      }


      function escapeHtml(v) {
          return normalizeText(v)
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#39;');
      }


      function toParagraphHtml(rawText) {
          return escapeHtml(rawText)
              .replace(BR_PLACEHOLDER, "\n")
              .replace(/\n/g, "<br>");
      }


      function splitSections(fullText) {
          const cleaned = normalizeSourceText(fullText);

          const s = cleaned.indexOf(MARKER_SUMMARY);
          const c = cleaned.indexOf(MARKER_CHAT);
          const o = cleaned.indexOf(MARKER_ORIG);

          // å…¼å®¹ Connector ç›´æ¥å†™å…¥çš„æƒ…å†µï¼šæ²¡æœ‰ç»“æ„æ ‡è®°ä¹Ÿèƒ½è½ç›˜
          if (s === -1 && c === -1 && o === -1) {
              return {
                  valid: true,
                  summary: cleaned,
                  chat: "",
                  original: "",
                  hasMarkers: false
              };
          }

          if (s === -1) {
              return {
                  valid: false,
                  reason: "âŒ æ‘˜è¦é‡Œæ²¡æ‰¾åˆ° 'AI Summary' æ ‡è®°ï¼Œè·³è¿‡ã€‚"
              };
          }

          if (o === -1) {
              return {
                  valid: false,
                  reason: "âŒ æ‰¾ä¸åˆ° Original Abstract æ ‡è®°ã€‚"
              };
          }

          const summaryEnd = (c > -1) ? c : o;

          return {
              valid: true,
              summary: cleaned.substring(s + MARKER_SUMMARY.length, summaryEnd).trim(),
              chat: c > -1 ? cleaned.substring(c + MARKER_CHAT.length, o).trim() : "",
              original: cleaned.substring(o + MARKER_ORIG.length).trim(),
              hasMarkers: true
          };
      }


      function formatChatHistory(rawChatString) {
          if (!rawChatString) return "";

          let segments = rawChatString.split(/(?=ğŸ‘¤ User:|ğŸ¤– AI:)/g);
          let html = '<div style="display: flex; flex-direction: column; gap: 16px;">';

          segments.forEach(seg => {
              seg = seg.trim();
              if (!seg) return;

              let cleanText = seg.replace(BR_PLACEHOLDER, "\n").trim();
              const isUser = cleanText.startsWith("ğŸ‘¤ User:");
              const isAi = cleanText.startsWith("ğŸ¤– AI:");

              if (!isUser && !isAi) return;

              const role = isUser ? 'ğŸ‘¤ User' : 'ğŸ¤– AI';
              const roleColor = isUser ? '#0d47a1' : '#616161';
              const bg = isUser ? '#bbdefb' : '#f5f5f5';
              const content = isUser ?
                  cleanText.replace("ğŸ‘¤ User:", "").trim() :
                  cleanText.replace("ğŸ¤– AI:", "").trim();

              html += `
                  <div style="padding: 12px 14px; border-radius: 12px; background: ${bg}; align-self: ${isUser ? 'flex-end' : 'flex-start'}; max-width: 92%; border: 1px solid ${isUser ? 'transparent' : '#eceff1'};">
                      <div style="color: ${roleColor}; font-size: 0.8em; margin-bottom: 6px; ${isUser ? 'text-align: right;' : ''}">${role}</div>
                      <div style="white-space: pre-wrap; font-family: -apple-system, BlinkMacSystemFont, sans-serif; color: #333; line-height: 1.5;">${escapeHtml(content)}</div>
                  </div>
              `;
          });

          html += '</div>';
          return html;
      }


      // === 4. å¤„ç†é€»è¾‘ ===

      async function processItem(targetItem) {
          const fullText = normalizeText(targetItem.getField('abstractNote'));

          if (!fullText) {
              return "âš ï¸ è·³è¿‡ï¼šæ¡ç›®æ‘˜è¦ä¸ºç©ºã€‚";
          }

          const parsed = splitSections(fullText);
          if (!parsed.valid) {
              return parsed.reason;
          }

          const rawSummary = parsed.summary;
          const rawChat = parsed.chat;
          const rawOrig = parsed.original;
          const hasMarkers = parsed.hasMarkers;

          const summaryHtml = toParagraphHtml(rawSummary);
          const chatHtml = formatChatHistory(rawChat);

          const title = targetItem.getField('title') || '[æ— æ ‡é¢˜]';

          const sectionMarker = hasMarkers ? MARKER_SUMMARY : 'ã€æ­£æ–‡å†…å®¹ã€‘';
          const markdownSource = `${sectionMarker}\n\n${normalizeText(rawSummary).replace(BR_PLACEHOLDER, "\n")}\n\n${rawChat ? `ã€ğŸ’¬ Chat Historyã€‘\n\n${normalizeText(rawChat).replace(BR_PLACEHOLDER, "\n")}\n\n` : ''}${rawOrig ? `ã€ğŸ“„ Original Abstractã€‘\n\n${normalizeText(rawOrig)}` : ''}`;

          let noteHTML = `
              <div style="font-family: -apple-system, BlinkMacSystemFont, sans-serif; color: #333;">
                  <h2 style="
                      background: transparent; 
                      color: #0277bd; 
                      padding: 0; 
                      margin-bottom: 15px; 
                      border-bottom: 2px solid #e1f5fe; 
                      display: inline-block;
                  ">
                      ğŸ¤– AI Summary
                  </h2>
                  <div style="margin-bottom: 30px;">
                      <div style="
                          display: block;
                          color: #333;
                          font-family: -apple-system, BlinkMacSystemFont, sans-serif;
                          font-size: 1em;
                          line-height: 1.6;
                          white-space: pre-wrap;
                          border: none;
                      ">${summaryHtml}</div>
                  </div>
          `;

          if (chatHtml) {
              noteHTML += `
                  <hr style="border: 0; border-top: 2px dashed #ccc; margin: 30px 0;">
                  <h3 style="
                      background: transparent; 
                      color: #444; 
                      padding: 0; 
                      margin-bottom: 20px;
                      border-bottom: 2px solid #eee;
                      display: inline-block;
                  ">
                      ğŸ’¬ Chat History
                  </h3>

                  ${chatHtml}
              `;
          }

          if (rawOrig) {
              const originalHtml = toParagraphHtml(rawOrig);
              noteHTML += `
                  <hr style="border: 0; border-top: 2px dashed #ccc; margin: 30px 0;">
                  <h3 style="
                      background: transparent; 
                      color: #444; 
                      padding: 0; 
                      margin-top: 26px; 
                      margin-bottom: 12px;
                  ">
                      ğŸ“„ Original Abstract
                  </h3>
                  <div style="white-space: pre-wrap; color: #555; line-height: 1.6;">${originalHtml}</div>
              `;
          }

          noteHTML += `
                  <details style="margin-top: 16px;">
                      <summary style="cursor: pointer; color: #0277bd;">ğŸ§® æ‰“å¼€ LaTeX/Markdown æºç </summary>
                      <div style="white-space: pre-wrap; background: #fafafa; border: 1px solid #e0e0e0; border-radius: 8px; padding: 12px;">${escapeHtml(markdownSource)}</div>
                  </details>
              </div>`;


          let newNote = new Zotero.Item('note');
          newNote.setNote(noteHTML);
          newNote.parentID = targetItem.id;
          await newNote.saveTx();

          targetItem.setField('abstractNote', normalizeText(rawOrig).replace(BR_PLACEHOLDER, "\n"));
          await targetItem.saveTx();

          return `âœ… [${escapeHtml(title)}] å¤„ç†å®Œæˆï¼ˆå« LaTeX/Markdown æºç æŠ˜å å—ï¼‰`;
      }


      const results = [];
      for (let i = 0; i < targetItems.length; i += 1) {
          results.push(await processItem(targetItems[i]));
      }

      return results.join("\n");
    shortcut: ''
    enabled: true
    menu: ''
    name: Process AI Summary
    showInMenu:
      item: false
      collection: false
      tools: false
      reader: false
      readerAnnotation: false
