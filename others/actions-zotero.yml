type: ActionsTagsBackup
author: zwwen0711
platformVersion: 7.0.30
pluginVersion: 2.2.4
timestamp: '2025-12-28T17:22:32.173Z'
actions:
  1766933168242-lENQeb2s:
    event: 1
    operation: 4
    data: >-
      const MARKER_SUMMARY = "ã€ğŸ¤– AI Summaryã€‘";
      const MARKER_CHAT = "ã€ğŸ’¬ Chat Historyã€‘";
      const MARKER_ORIG = "ã€ğŸ“„ Original Abstractã€‘";
      const BR_PLACEHOLDER = /__BR__/g;
      const AUTO_NOTE_TAG = "dpr-ai-summary-note";
      const RETRY_DELAYS = [300, 800, 1500];

      const targetItems = (typeof items !== "undefined" && items && items.length > 0)
        ? items
        : ((typeof item !== "undefined" && item) ? [item] : []);

      if (!targetItems || targetItems.length === 0) {
        return "âŒ é”™è¯¯ï¼šæœªæ¥æ”¶åˆ°æœ‰æ•ˆæ¡ç›®ï¼ˆè¯·å…ˆåœ¨æ¡ç›®ä¸Šè§¦å‘è„šæœ¬ï¼‰";
      }

      function normalizeText(v) {
        return (v || "").toString();
      }

      function normalizeSourceText(v) {
        const plain = normalizeText(v)
          .replace(/<br\s*\/?>/gi, "\n")
          .replace(/<\/p>/gi, "\n")
          .replace(/<p[^>]*>/gi, "")
          .replace(/<[^>]+>/g, "")
          .replace(BR_PLACEHOLDER, "\n")
          .replace(/\r/g, "\n");
        return plain
          .replace(/\n{3,}/g, "\n\n")
          .trim();
      }

      function hasAnyMarker(text) {
        return (
          text.includes(MARKER_SUMMARY) ||
          text.includes(MARKER_CHAT) ||
          text.includes(MARKER_ORIG)
        );
      }

      function cleanForCompare(v) {
        return normalizeSourceText(v).replace(/\s+/g, "");
      }

      function escapeHtml(v) {
        return normalizeText(v)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function getFieldSafe(targetItem, fieldName) {
        try {
          return normalizeText(targetItem.getField(fieldName));
        } catch (err) {
          return "";
        }
      }

      function getSourceText(targetItem) {
        const candidateFields = [
          "citation_abstract",
          "dc.description",
          "DC.description",
          "description",
          "abstract",
          "abstractNote",
          "extra",
        ];
        let bestText = "";
        let bestLength = 0;
        for (const fieldName of candidateFields) {
          const raw = normalizeSourceText(getFieldSafe(targetItem, fieldName));
          if (!raw) {
            continue;
          }

          if (hasAnyMarker(raw)) {
            return raw;
          }

          if (raw.length > bestLength) {
            bestText = raw;
            bestLength = raw.length;
          }
        }
        return bestText;
      }

      function classifySectionTitle(title) {
        const source = normalizeText(title).trim();
        const raw = source
          .toLowerCase()
          .replace(/^\s*#{1,6}\s*/, "")
          .trim();
        const isPotentialHeader =
          /^#{1,6}\s/.test(source) || /^[ğŸ¤–ğŸ’¬ğŸ“„]/.test(source);
        if (!isPotentialHeader) {
          return "";
        }

        if (
          raw.includes("è®ºæ–‡è¯¦ç»†æ€»ç»“") ||
          raw.includes("ai summary") ||
          raw.includes("ğŸ¤– ai summary") ||
          raw.includes("è¯¦ç»†æ€»ç»“")
        ) {
          return "summary";
        }
        if (raw.includes("chat history") || raw.includes("ğŸ’¬ chat history")) {
          return "chat";
        }
        if (
          raw.includes("original abstract") ||
          raw.includes("åŸå§‹æ‘˜è¦") ||
          raw.includes("åŸæ–‡æ‘˜è¦")
        ) {
          return "original";
        }
        return "";
      }

      function trimLeadingMetadataLines(text) {
        const lines = normalizeSourceText(text).split("\n");
        const filtered = [];
        let started = false;
        for (const line of lines) {
          const t = line.trim();
          if (!t) {
            if (!started) {
              continue;
            }
          }
          if (!started && t.startsWith("Tags:")) {
            continue;
          }
          if (!started && /^> ç”± daily-paper-reader è‡ªåŠ¨ç”Ÿæˆ/i.test(t)) {
            continue;
          }
          if (!started && t.includes("daily-paper-reader è‡ªåŠ¨ç”Ÿæˆ")) {
            continue;
          }
          started = true;
          filtered.push(t);
        }
        return filtered
          .join("\n")
          .replace(/\n{3,}/g, "\n\n")
          .trim();
      }

      function splitByHeadings(text) {
        const lines = normalizeSourceText(text).split("\n");
        const result = { summary: "", chat: "", original: "" };
        let currentType = "";
        let buffer = [];

        const flush = () => {
          if (!currentType) {
            return;
          }
          if (!result[currentType]) {
            const merged = trimLeadingMetadataLines(buffer.join("\n"));
            if (merged) {
              result[currentType] = merged;
            }
          }
          buffer = [];
        };

        for (const rawLine of lines) {
          const line = rawLine.trim();
          const headerType = classifySectionTitle(line);
          const isPotentialHeading = /^#{1,6}\s/.test(line) || /^[ğŸ¤–ğŸ’¬ğŸ“„]/.test(line);
          if (headerType || isPotentialHeading) {
            flush();
            currentType = headerType && !result[headerType] ? headerType : "";
            continue;
          }
          if (currentType) {
            buffer.push(rawLine);
          }
        }
        flush();
        return result;
      }

      function extractFirstSectionBlock(text) {
        const lines = normalizeSourceText(text).split("\n");
        const out = [];
        for (const rawLine of lines) {
          if (classifySectionTitle(rawLine.trim())) {
            break;
          }
          out.push(rawLine);
        }
        return trimLeadingMetadataLines(out.join("\n"));
      }

      function splitByMarkersIfNeed(text) {
        const s = text.indexOf(MARKER_SUMMARY);
        const o = text.indexOf(MARKER_ORIG);
        const c = text.indexOf(MARKER_CHAT);
        if (s === -1 && o === -1 && c === -1) {
          return { summary: "", chat: "", original: "" };
        }

        const nextOf = (start) => {
          let next = -1;
          [MARKER_SUMMARY, MARKER_CHAT, MARKER_ORIG].forEach((marker) => {
            const p = text.indexOf(marker, start);
            if (p > -1 && (next === -1 || p < next)) {
              next = p;
            }
          });
          return next === -1 ? text.length : next;
        };

        const summary = s === -1
          ? ""
          : trimLeadingMetadataLines(text.substring(s + MARKER_SUMMARY.length, nextOf(s + MARKER_SUMMARY.length)));
        const chat = c === -1
          ? ""
          : trimLeadingMetadataLines(text.substring(c + MARKER_CHAT.length, nextOf(c + MARKER_CHAT.length)));
        const original = o === -1
          ? ""
          : trimLeadingMetadataLines(text.substring(o + MARKER_ORIG.length, nextOf(o + MARKER_ORIG.length)));

        return { summary, chat, original };
      }

      function splitSections(fullText) {
        const cleaned = normalizeSourceText(fullText);
        if (!cleaned) {
          return {
            valid: false,
            reason: "âš ï¸ æ¡ç›®æ‘˜è¦ä¸ºç©ºï¼Œç­‰å¾…é‡è¯•ä¸­ã€‚",
          };
        }

        const headingParsed = splitByHeadings(cleaned);
        if (headingParsed.summary || headingParsed.original || headingParsed.chat) {
          const summary = headingParsed.summary;
          const original = headingParsed.original;
          const chat = headingParsed.chat;
          if (
            summary &&
            original &&
            cleanForCompare(summary) === cleanForCompare(original)
          ) {
            return {
              valid: true,
              summary,
              chat,
              original: "",
            };
          }
          return {
            valid: true,
            summary: headingParsed.summary,
            chat: headingParsed.chat,
            original: headingParsed.original,
          };
        }

        const markerParsed = splitByMarkersIfNeed(cleaned);
        if (markerParsed.summary || markerParsed.original || markerParsed.chat) {
          const summary = markerParsed.summary;
          const original = markerParsed.original;
          const chat = markerParsed.chat;
          if (
            summary &&
            original &&
            cleanForCompare(summary) === cleanForCompare(original)
          ) {
            return {
              valid: true,
              summary,
              chat,
              original: "",
            };
          }
          return {
            valid: true,
            summary: markerParsed.summary,
            chat: markerParsed.chat,
            original: markerParsed.original,
          };
        }

        return {
          valid: true,
          summary: cleaned,
          chat: "",
          original: "",
        };
      }

      function formatChatMarkdown(rawChatString) {
        if (!rawChatString) {
          return "";
        }
        const segments = rawChatString.split(/(?=ğŸ‘¤ User:|ğŸ¤– AI:)/g);
        const lines = [];
        for (const seg of segments) {
          const cleanText = normalizeSourceText(seg).trim();
          if (!cleanText) {
            continue;
          }
          if (cleanText.startsWith("ğŸ‘¤ User:")) {
            lines.push(`**ğŸ‘¤ User:**\n${cleanText.replace("ğŸ‘¤ User:", "").trim()}`);
          } else if (cleanText.startsWith("ğŸ¤– AI:")) {
            lines.push(`**ğŸ¤– AI:**\n${cleanText.replace("ğŸ¤– AI:", "").trim()}`);
          }
        }
        return lines.join("\n\n");
      }

      function buildNoteMarkdown(parsed) {
        const blocks = [];
        const addBlock = (title, content) => {
          if (!content) return;
          blocks.push(`## ${title}`);
          blocks.push(content);
        };

        const stripLeadingHeading = (text, title) => {
          const escaped = title.replace(
            /[.*+?^${}()|[\]\\]/g,
            "\\$&",
          );
          return text
            .replace(
              new RegExp(`^\\s*#{1,6}\\s*${escaped}\\s*\\n+`, "i"),
              "",
            )
            .trim();
        };

        const summaryText = parsed.summary
          ? extractFirstSectionBlock(
              trimLeadingMetadataLines(
                stripLeadingHeading(parsed.summary, "ğŸ¤– AI Summary"),
              ),
            )
          : "";
        const originalText = parsed.original
          ? extractFirstSectionBlock(
              trimLeadingMetadataLines(
                stripLeadingHeading(parsed.original, "ğŸ“„ Original Abstract"),
              ),
            )
          : "";

        const shouldKeepOriginal =
          !(summaryText && originalText &&
            cleanForCompare(summaryText) === cleanForCompare(originalText));

        addBlock(
          "ğŸ¤– AI Summary",
          summaryText || "ï¼ˆæœªæ£€æµ‹åˆ° AI Summaryï¼Œå·²è‡ªåŠ¨é™çº§å±•ç¤ºåŸå§‹å†…å®¹ï¼‰",
        );

        if (parsed.chat) {
          const chatText = formatChatMarkdown(parsed.chat);
          addBlock("ğŸ’¬ Chat History", chatText);
        }
        if (shouldKeepOriginal && originalText) {
          addBlock("ğŸ“„ Original Abstract", originalText);
        }
        return blocks.join("\n\n");
      }

      function markdownToPlainHtml(markdownText) {
        const lines = normalizeText(markdownText).split(/\n/);
        const htmlParts = [];
        let paragraphBuffer = [];
        const flushParagraph = () => {
          if (!paragraphBuffer.length) {
            return;
          }
          const blockText = paragraphBuffer.join("\n").trim();
          if (!blockText) {
            paragraphBuffer = [];
            return;
          }
          const headingMatch = blockText.match(/^(#{1,6})\s+(.*)$/);
          if (headingMatch) {
            const level = Math.min(6, headingMatch[1].length);
            htmlParts.push(
              `<h${level} style=\"margin: 14px 0 8px 0; color:#0277bd; border-bottom:1px solid #e3f2fd;\">${escapeHtml(
                headingMatch[2],
              )}</h${level}>`,
            );
          } else if (/^\s*>\s*/.test(blockText)) {
            htmlParts.push(
              `<blockquote style=\"margin: 12px 0; padding-left: 12px; color:#666; border-left: 3px solid #bbdefb; white-space: pre-wrap;\">${escapeHtml(
                blockText.replace(/^\s*>\s*/, ""),
              ).replace(/\n/g, "<br>")}</blockquote>`,
            );
          } else {
            const esc = escapeHtml(blockText).replace(/\n/g, "<br>");
            htmlParts.push(
              `<p style=\"display:block; color: #333; font-size: 1em; line-height: 1.6; white-space: pre-wrap; margin: 0 0 12px 0;\">${esc}</p>`,
            );
          }
          paragraphBuffer = [];
        };

        for (const line of lines) {
          if (!line.trim()) {
            flushParagraph();
            continue;
          }
          paragraphBuffer.push(line);
        }
        flushParagraph();

        return `<div style="font-family: -apple-system, BlinkMacSystemFont, sans-serif; color: #333; line-height: 1.6;">${htmlParts
          .filter(Boolean)
          .join("")}</div>`;
      }

      function hasAutoSummaryNote(targetItem) {
        try {
          const notes = Zotero.Items.get(targetItem.getNotes()) || [];
          return notes.some((note) => {
            const tags = note.getTags ? note.getTags() : [];
            if (tags?.some((tagItem) => tagItem.tag === AUTO_NOTE_TAG)) {
              return true;
            }
            const title = normalizeText(note.getNoteTitle ? note.getNoteTitle() : "")
              .toLowerCase();
            if (title.includes("ai summary") || title.includes("daily-paper")) {
              return true;
            }
            const noteHtml = normalizeText(note.getNote()).toLowerCase();
            return (
              noteHtml.includes("ğŸ¤– ai summary") ||
              noteHtml.includes("ğŸ“„ original abstract") ||
              noteHtml.includes("dpr-ai-summary-note")
            );
          });
        } catch (err) {
          return false;
        }
      }

      async function removeAutoSummaryNotes(targetItem) {
        try {
          const notes = Zotero.Items.get(targetItem.getNotes()) || [];
          for (const note of notes) {
            const tags = note.getTags ? note.getTags() : [];
            const hasTag = tags?.some((tagItem) => tagItem.tag === AUTO_NOTE_TAG);
            if (!hasTag) {
              const title = normalizeText(note.getNoteTitle ? note.getNoteTitle() : "")
                .toLowerCase();
              const noteHtml = normalizeText(note.getNote()).toLowerCase();
              const isAuto =
                title.includes("ai summary") ||
                title.includes("daily-paper") ||
                noteHtml.includes("ğŸ¤– ai summary") ||
                noteHtml.includes("ğŸ“„ original abstract");
              if (!isAuto) {
                continue;
              }
            }

            try {
              if (note.eraseTx) {
                await note.eraseTx();
              } else if (note.deleteTx) {
                await note.deleteTx();
              }
            } catch (err) {
              // ignore removal failure
            }
          }
        } catch (err) {
          // ignore removal process
        }
      }

      async function processItem(targetItem) {
        const title = normalizeText(targetItem.getField("title")) || "[æ— æ ‡é¢˜]";

        if (hasAutoSummaryNote(targetItem)) {
          await removeAutoSummaryNotes(targetItem);
        }

        let sourceText = "";
        for (let i = 0; i <= RETRY_DELAYS.length; i += 1) {
          sourceText = getSourceText(targetItem);
          if (sourceText) {
            break;
          }
          if (triggerType === "createItem" && i < RETRY_DELAYS.length) {
            await sleep(RETRY_DELAYS[i]);
          }
        }

        if (!sourceText) {
          return `âš ï¸ [${escapeHtml(title)}] æš‚æœªè¯»åˆ°æ‘˜è¦ï¼Œå¯¼å…¥å¤±è´¥`;
        }

        const parsed = splitSections(sourceText);
        if (!parsed.valid) {
          return parsed.reason;
        }

        const noteMarkdown = buildNoteMarkdown(parsed);
        let noteHtml = "";
        const canUseBetterNotes =
          !!(
            Zotero.BetterNotes &&
            Zotero.BetterNotes.api &&
            Zotero.BetterNotes.api.convert &&
            Zotero.BetterNotes.api.convert.md2html &&
            Zotero.BetterNotes.api.note &&
            Zotero.BetterNotes.api.note.insert
          );

        if (canUseBetterNotes) {
          try {
            noteHtml = await Zotero.BetterNotes.api.convert.md2html(noteMarkdown);
          } catch (err) {
            noteHtml = markdownToPlainHtml(noteMarkdown);
          }
        } else {
          noteHtml = markdownToPlainHtml(noteMarkdown);
        }

        const newNote = new Zotero.Item("note");
        newNote.libraryID = targetItem.libraryID;
        newNote.parentID = targetItem.id;
        newNote.addTag(AUTO_NOTE_TAG, 1);
        newNote.setNote(noteHtml);
        await newNote.saveTx();

        if (canUseBetterNotes && Zotero.BetterNotes?.api?.note?.insert) {
          try {
            await Zotero.BetterNotes.api.note.insert(newNote, noteHtml, -1);
          } catch (err) {
            // fallback to standard note API
          }
        }

        if (parsed.original) {
          targetItem.setField(
            "abstractNote",
            normalizeText(parsed.original).replace(BR_PLACEHOLDER, "\n"),
          );
          await targetItem.saveTx();
        }

        return `âœ… [${escapeHtml(title)}] å·²è‡ªåŠ¨åˆ›å»º AI Summary æ¡ç›®ç¬”è®°`;
      }

      const results = [];
      for (let i = 0; i < targetItems.length; i += 1) {
        results.push(await processItem(targetItems[i]));
      }

      return results.join("\n");
    shortcut: ''
    enabled: true
    menu: ''
    name: Process AI Summary
    showInMenu:
      item: false
      collection: false
      tools: false
      reader: false
      readerAnnotation: false
